// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: tpvector.icc,v 1.7 2000/03/10 15:53:24 gcosmo Exp $
// GEANT4 tag $Name: geant4-02-00 $
//
// 
//---------------------------------------------------------------
//  GEANT 4 class header file
//
//  G4RWTPtrVector
//---------------------------------------------------------------

template<class T>
G4RWTPtrVector<T>::G4RWTPtrVector ()
  : std_pvector(), rwsize(0){}

template<class T>
G4RWTPtrVector<T>::G4RWTPtrVector (size_t n)
  : std_pvector(n, (T*)0), rwsize(n){}  // Here Rogue-Wave would leave
                                        // pointers T* uninitialised.
template<class T>
G4RWTPtrVector<T>::G4RWTPtrVector (size_t n, T* const & iPtr)
  : std_pvector(n, iPtr), rwsize(n){}

template<class T>
G4RWTPtrVector<T>::G4RWTPtrVector (const G4RWTPtrVector<T>& iPtr)
  : std_pvector(iPtr), rwsize(iPtr.rwsize){}

template<class T>
G4RWTPtrVector<T>::~G4RWTPtrVector(){}

template<class T>
G4RWTPtrVector<T>& G4RWTPtrVector<T>::operator = (T* p)
{
  rwsize=0;
  for(iterator i = std_pvector::begin(); i != std_pvector::end(); ++i)
    {
      *i = p; rwsize++;
    }
  return *this;
}
  
template<class T>
T* G4RWTPtrVector<T>::operator () ( size_t n ) const
{
  #ifdef G4DEBUG
    if(n>=rwsize)
      G4RWTHROW(G4RWBoundsErr("G4RWTPtrVector operator()",rwsize,n));
  #endif
  return std_pvector::operator[](n);
}

template<class T>
T*& G4RWTPtrVector<T>::operator () ( size_t n )
{
  // temporarly commented; to allow use as left-value rwsize is increased
  // #ifdef G4DEBUG
  //   if(n>=rwsize)
  //     G4RWTHROW(G4RWBoundsErr("G4RWTPtrVector operator()",rwsize,n));
  // #endif
  if(rwsize<=n && n<std_pvector::size())
    rwsize=n+1;
  return std_pvector::operator[](n);
}

// The [] operator should perform bound checking
//	
template<class T>
T* G4RWTPtrVector<T>::operator [] ( size_t n ) const
{
  if(n>=rwsize)
    G4RWTHROW(G4RWBoundsErr("G4RWTPtrVector",rwsize,n));
  return std_pvector::operator[](n);
}

template<class T>
T*& G4RWTPtrVector<T>::operator [] ( size_t n )
{
  if(n>=rwsize)
    G4RWTHROW(G4RWBoundsErr("G4RWTPtrVector",rwsize,n));
  return std_pvector::operator[](n);
}

template<class T>
T* const * G4RWTPtrVector<T>::data() const
{
  return &(std_pvector::front());
}

template<class T>
size_t G4RWTPtrVector<T>::length()
{
  return std_pvector::size();
}

template<class T>
void G4RWTPtrVector<T>::resize ( size_t n )
{
  if(n>std_pvector::size())
    {
      int e=n-std_pvector::size();
      for(int i=0;i<e;i++)
        std_pvector::push_back(0);
    }
  else
    {
      std_pvector::resize(n);
    }
  rwsize=n;
}

template<class T>
void G4RWTPtrVector<T>::reshape( size_t n )
{
  std_pvector::resize(n);
  rwsize=n;
}
