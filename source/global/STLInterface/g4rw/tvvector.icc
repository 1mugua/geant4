// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: tvvector.icc,v 1.4 2000/11/20 17:26:45 gcosmo Exp $
// GEANT4 tag $Name: geant4-03-01 $
//
// 
//---------------------------------------------------------------
//  GEANT 4 class header file
//
//  G4RWTValVector
//---------------------------------------------------------------

template<class T>
G4RWTValVector<T>::G4RWTValVector ()
  : std_vector(), rwsize(0){}

template<class T>
G4RWTValVector<T>::G4RWTValVector (size_t n)
  : std_vector(n,T()), rwsize(n){}

template<class T>
G4RWTValVector<T>::G4RWTValVector (size_t n, const T& ival)
  : std_vector(n,ival), rwsize(n){}

template<class T>
G4RWTValVector<T>::G4RWTValVector (const G4RWTValVector<T>& ival)
  : std_vector(ival), rwsize(ival.rwsize){}

template<class T>
G4RWTValVector<T>::~G4RWTValVector(){}

template<class T>
G4RWTValVector<T>&
G4RWTValVector<T>::operator= (const G4RWTValVector<T>& v)
{
  std_vector::operator=(v);
  rwsize=v.rwsize;
  return *this;     
}

template<class T>
size_t G4RWTValVector<T>::length() const
{
  return std_vector::size();
}

template<class T>
T& G4RWTValVector<T>::operator()(size_t i) 
{
  // temporarly commented; to allow use as left-value rwsize is increased
  // #ifdef G4DEBUG
  //   if(i>=rwsize)
  //     G4RWTHROW(G4RWBoundsErr("G4RWTValVector operator()",rwsize,i));
  // #endif
  if(rwsize<=i && i<std_vector::size())
    rwsize=i+1;
  return std_vector::operator[](i); 
}

template<class T>
const T& G4RWTValVector<T>::operator()(size_t i) const
{
  #ifdef G4DEBUG
    if(i>=rwsize)
      G4RWTHROW(G4RWBoundsErr("G4RWTValVector operator()",rwsize,i));
  #endif
  return std_vector::operator[](i);
}

template<class T>
T& G4RWTValVector<T>::operator[](size_t i) 
{
  if(i>=rwsize)
    G4RWTHROW(G4RWBoundsErr("G4RWTValVector operator[]",rwsize,i));
  return std_vector::operator[](i); 
}

template<class T>
const T& G4RWTValVector<T>::operator[](size_t i) const
{ 
  if(i>=rwsize)
    G4RWTHROW(G4RWBoundsErr("G4RWTValVector const operator[]",rwsize,i));
  return std_vector::operator[](i); 
}

template<class T>
const T* G4RWTValVector<T>::data() const
{
  return &(std_vector::front());
}

template<class T>
void G4RWTValVector<T>::resize(size_t N)
{
  if(N>std_vector::size())
    {
      size_t e=N-std_vector::size();
      for(size_t i=0;i<e;i++)
        std_vector::push_back(T());
    }
  else
    {
      iterator it=std_vector::begin();
      for(size_t i=1;i<=N;i++,it++);
      std_vector::erase(it,std_vector::end());
    }
  rwsize=N;
}

template<class T>
void G4RWTValVector<T>::reshape(size_t n)
{
  resize(n);
}

template<class T>
const T& G4RWTValVector<T>::ref(size_t i) const
{
  return std_vector::operator[](i);
}	
